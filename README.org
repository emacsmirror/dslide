#+title:	Macro Slides
#+author:	Positron
#+email:	contact@positron.solutions

* Installation
This isn't on a package archive yet.  Subscribe to Positron's [[https://www.youtube.com/@Positron-gv7do][YouTube]] for updates.
 #+begin_src elisp
   ;; package-vc
   (package-vc-install
    '(macro-slides
      :url "https://github.com/positron-solutions/macro-slides.git"))

   ;; using elpaca's with explicit recipe
   (use-package macro-slides
     :elpaca (macro-slides :host github
                           :repo "positron-solutions/macro-slides"))

   ;; straight with explicit recipe
   (use-package macro-slides
     :straight (macro-slides :type git :host github
                             :repo "positron-solutions/macro-slides"))

   ;; or use manual load-path & require, you brave yak shaver
 #+end_src
** Try It Out
With just defaults, run ~ms-start~ on your existing documents.  You can load the examples in the =/test= directory to see a showcase of configuration behavior.

The default keymap uses arrow keys.  Left and right are ~ms-forward~ and ~ms-backward~.  Up is ~ms-start~ and will show the contents.  Down is ~ms-stop~ and will stop the slide show.
* Overview
- A presentation framework that can incorporate *anything* Emacs does
- Any buffer can be part of a presentation sequence
- Present Org documents with babel integration
- Extensible presentation sequences and display options
** Simple User Interface
Fully programmable sequences behind a two-button interface:
- ~ms-forward~
- ~ms-backward~
** Present Org Documents ü¶Ñ
- Document header generated from keywords
- Breadcrumbs
- By default, every heading and child heading is a slide
- Configurable slide behavior using pre-built actions
- Consume typical org data like inline images with full-frame display
** Fully Programmable ‚ú®
- Directly script your presentation with Org babel blocks
- Convenient API for quickly writing reliable custom actions
- Integration with Elisp programs and arbitrary Emacs buffers
- Custom class support for extending the framework
** Status üõ†Ô∏è
Version 0.2.1 üë∑
- Deciding the configuration API and naming
- Gathering user feedback & experience
- Accepting PR's and issue reports

The internal API is beginning to stabilize.  I think the user API will look pretty similar to what is already there today, but if any keys change, I'll call ~warn~ on the old keys.
* Features
** Contents Navigation
Call ~ms-contents~ to show a contents overview.  Calling ~ms-forward~ and ~ms-backward~ in the contents can quickly move through headings.  Call ~ms-start~ again to resume the presentation from that point.
** Clean Buffer State
The actual display is done in an indirect buffer.  Your hooks and customizations for presentation will not pollute your editing buffer.  Dirty state will not pile up in your presentation buffer, greatly increasing reliability even if your custom Elisp scripting is sloppy üí©.
** Follow Along
If you display the slideshow in one window or frame, you can configure the point to follow the slide in the base buffer, enabling you to see the full markup and even edit the presentation while developing your customizations.
* Glossary
- *Deck*: an object that is used to relate the display and base buffer and is the root of all sequences
- *Slide*: an object that interprets an org heading to hydrate its actions
- *Action*: an object that responds to ~ms-forward~ and ~ms-backward~ calls and implements lifecycle methods to initialize and clean up state
- *Step*: a single call to ~ms-foward~ or ~ms-backward~, usually delegated down to ~ms-step-forward~ and ~ms-step-backward~ methods
- *Contents*: use org folding to create a view of folded headings to quickly navigate slides
- *Slide Buffer*: the slides are shown in an indirect buffer that is cloned from your org document buffer.  The source is called the *base buffer*.  Check for the =deck: my-presentation.org= buffer name.
  + Inderect buffer and =slide-buffer= are used interchangeably
  + Base buffer or =base-buffer= is used pretty execlusively
* Configuring
Be sure to check =M-x= ~customize-group~ =macro-slides= to see all declared custom variables. All of the variables are configured to recommended defaults except hooks, which would depend on other packages usually.

Many settings can be configured at the global level through customize variables, the document level through keywords, and the slide level through the property drawer.
** Binding
You likely want to start the mode via ~ms-start~.  Once the mode starts, it creates an indirect buffer to display the slides and then calls ~ms-start-function~ once the mode is active and everything is initialized, so you can customize startup behavior.
#+begin_src elisp
  (keymap-set org-mode-map [f5] #'ms-start)
#+end_src
Once the global minor mode, ~ms-mode~ is active, additional bindings in ~ms-mode-map~ are active in every buffer so that you can integrate other buffers into your presentation.  (Tracking which buffers are part of a presentation is  still a topic under consideration üöß)
*** Secondary Commands üöß
Because you might want to play a video or take a branch in the presentation and then exit that branch, the plan is to overload the ~ms-start~ binding within presentations to enter / exit these branches.
** Hooks
Because slides and actions have a life-cycle and can easily find their own heading, consider making a custom action and setting that action on slides where it's needed.

Beware of using the normal ~ms-mode-hook~ üò± because it runs *in the base buffer* ‚ö†Ô∏è.  If you remap faces or add a bunch of styling, it will be copied to the indirect buffer but then linger in your base buffer.  Instead, use ~ms-start-hook~. üí°

- ~ms-start-hook~ Is run in the indirect buffer after it is set it.  This is what you want.
- ~ms-stop-hook~ is run in the base buffer because the indirect buffer is already dead.
- ~ms-contents-hook~ is run after switching to contents.  It runs in the display buffer.
- ~ms-narrow-hook~ is run whenever a ~ms-forward~ or ~ms-backward~ changes the narrow state.  Because this is done by watching the restriction, it might do what you want ü§∑üèª‚Äç‚ôÇÔ∏è
- ~ms-after-last-slide-hook~ is run when the user tries to go forward but there are no more slides.  You can use this to implement a final feedback before exiting the presentation or set it to just ~ms-stop~ to exit without feedback.  Another option is to use ~ms-push-step~ to push a callback that will only run when called going forward.
#+begin_src elisp
  (defun my-stop-if-forward ()
    (mc-push-step (lambda (direction)
                    (when (eq direction 'forward)
                      ;; Be sure to return t or the hook will run again.
                      (prog1 t (ms-stop))))))

  (setq ms-after-last-slide-hook #'my-stop-if-forward)
#+end_src
** Recommended MC Settings
The out-of-the-box experience can be a bit messy due to property drawers, keywords, and babel blocks that you might include.  You probably want to hide these elements.  [[https://github.com/positron-solutions/master-of-ceremonies][Master of Ceremonies]] contains some flexible hiding that can be updated with each slide and turned on and off only when the slideshow is active.
#+begin_src elisp
  ;; Something like this should work
  (add-hook 'ms-start-hook mc-hide-markup-mode)
  (add-hook 'ms-narrow-hook #'mc-hide-refresh)
#+end_src
** Heading Properties
Headings are treated as slides.  Slides have actions.  Actions are configured in the property drawer.

- =MS_SLIDE_ACTION=: Usually narrows to the slide.  Lifecycle encloses the section.
- =MS_SECTION_ACTIONS:= Most commonly customized.  You can list multiple actions.  Each one will step through its forward and backward steps.
- =MS_CHILD_ACTION=: Used to customize if and how child headings become slides

Some actions must be fully enclosed by the lifecycle of a surrounding action, such as narrowing to the headline and section before displaying a contained list item-by-item.

üöß Likely in the future, actions will be composable and accept arguments, using Lisp s-expressions.  This API should be forward compatible.
*** Example
Regular Org Mode markup is used to add actions to headings.  See more examples in the [[../test]] directory.
#+begin_src org
  ,* Full Screen Images
  :PROPERTIES:
  :MS_ACTIONS: ms-action-images
  :END:
  ,#+attr_html: :width 50%
  [[./images/emacsen4.jpeg]] [[./images/before-google3.jpeg]]
#+end_src
*** Action Arguments
Many actions understand arguments, allowing tuning of similar behaviors from the same class.  Implementing new arguments is relatively easy, just adding a slot and then reacting to the value of that slot.

Configuring the slot is done by adding plist-style properties after the class name:
#+begin_src org
  :PROPERTIES:
  :MS_SECTION_ACTIONS: ms-action-item-reveal :inline t
  :END:
#+end_src
You can also use "property+" syntax to add to a property, and these accept plist arguments too:
#+begin_src org
  :PROPERTIES:
  :MS_SECTION_ACTIONS: ms-action-babel
  :MS_SECTION_ACTIONS+: ms-action-images :refresh t
  :END:
#+end_src
* Customizing
** Sub-classing
The deck and slide class as well as actions can all be sub-classed.  Use the existing sub-classes of actions as example code for writing other classes.  See the [[info:eieio#Top][eieio#Top]] manual for explanation of OOP in Elisp.

- *Action*:  Creating new action subclasses are an efficient way to perform similar operations on typical kinds of org data.
- *Slide:*  Slides can be configured extensively by changing their actions.  However, for more vertical cooperation between slides or cooperation among actions, extended slides could be useful.
- *Deck*:  If the core methods of the deck are insufficient, extension is another option besides advice, hooks, and modifying the source.

If you suspect you might need to sub-class the ~ms-slide~ or ~ms-deck~, please file an issue because your use case is probably interesting.
** Default Classes
The default classes and actions can be configured at the document or customize level.  Set the =MS_DECK_CLASS= and =MS_SLIDE_CLASS= as well as other properties that work at the heading level.  The order of precedence (*Not fully implemented* üöß):
- Property definition of the current heading
- Property definition in the document
- Customize variable
** Babel Scripting
You can write custom scripts into your presentation as Org Babel blocks.  These can be executed with the ~ms-action-babel~ action.  You just need to label your blocks with lifecycle methods if you want to be able to go forwards and backwards.  See the ~ms-action-babel~ class and examples in [[./test/demo.org]].

The =#+attr_ms:= affiliated keyword is used to configure which methods will run the block.  Block labels that are understood:

- =init= and =end= are run when the slide is instantiated, going forward and backward respectively.  You can have several blocks with these methods, and they will be run from *top-to-bottom* always, making it easier to re-use code usually.

- =final= is only called when no progress can be made or if the presentation is stopped.

- =step-forward= and =step-backward= are self-explanatory.  Position your =step-backward= blocks *above* any block that they undo

- =step-both= runs either direction.  It will not repeat in place when reversing.  Use sepate =step-forward= and =step-backward= blocks for that üí°
*** Step Callbacks
See ~ms-push-step~ for inserting arbitrary callbacks that can function as steps.  Unless your action performs state tracking to decide when to consume ~ms-forward~ and ~ms-backward~ itself, a callback may be easier.

Because babel blocks are not actions, using ~ms-push-step~ may be the only way to optionally add a step callback from a babel block.
* Package Pairings
This package is focused on creating a linear presentation sequence. For functionality not related to integrations into the ~ms-forward~ ~ms-backward~ interface, it is better to maintain separate packages and use hooks and babel scripting.
** Master of Ceremonies
The [[https://github.com/positron-solutions/master-of-ceremonies][master-of-ceremonies]] package contains utilities for display & presentation frame setup that are not specific to using Macro Slides.
- *hide markup*
- display a region full-screen
- silence messages during presentation
- hide the cursor or make it very subtle
- extract notes and display them in a separate frame
** Open Broadcaster Software
Sacha Chua has written an OBS plugin integration helpful for video integration [[https://github.com/sachac/obs-websocket-el][obs-websocket-el]].
** Orgit
~orgit~ can be used to show commits as links, which open with =ms-action-links=
** moom.el
The [[https://github.com/takaxp/moom#org-mode-org-tree-slide][moom]] package contains some commands for resizing text and repositioning frames.
* Domain Model
This is a description of how the pieces of the program *must* fit together.  For any deep customization or hacking, the section is essential reading.  At the least, it will *greatly improve your success*.

‚ö†Ô∏è Even if the current implementation differs, trust this domain model and expect the implementation to approach it.

- The user interface ~ms-forward~ and ~ms-backward~ is a concrete requirement that drives most of the rest of the implementation and feature design.
- There are several ways to linearize the tree structure of org headings and to compose their presentation.  Sequences of forward and backward actions must be nested to accomplish many desirable goals.
- Supporting nested sequences can be made to implement just about anything while still keeping the user interface simple.
** Stateful Sequence Class
This class is the heart of providing the common user interface and convenient implementation interface for extending the package.
*** Command Pattern
The basis of all undo systems is to implement reverse actions that decide their behavior from the updated state or to save mementos that allow undoing forward actions.  This is the [[https://en.wikipedia.org/wiki/Command_pattern][command pattern]].

Navigating the linear sequence of a presentation is very similar to an undo system.  Log-backed architectures such as git or event-sourcing can similarly be viewed as navigating to any point in a sequence by applying or rolling back a sequence of changes.
*** Setup & Teardown
At the boundaries of a sequence of forward and reverse actions, it may be necessary to build up or tear down some state.  The stateful sequence adds ~ms-init~, ~ms-final~, and a variation of ~ms-init~, ~ms-end~.

The role of ~ms-end~ is to perform initialization at the end.  It is optional as the default implementation is to call ~ms-int~ and then ~ms-step-forward~ until no more progress can be made.  However, this may be costly or undesirable due to side-effects.
*** Indexing Via Point
In order to support contents based navigation, we need to be able to play a slide forward up to the current point.  This may require instantiating some parent slides and playing them forward to a child.  To avoid the need for parents to know about children, the ~ms-goto~ method was introduced.
*** Stateful Sequence Interface
The conclusion of the command pattern, setup & teardown, and indexing via point is the ~ms-stateful-sequence~ class.  Anything that implements its interface can be controlled by ~ms-forward~ and ~ms-backward~.  The full interface:

- ~ms-init~ & ~ms-end~
- ~ms-final~
- ~ms-step-forward~ & ~ms-step-backward~
- ~ms-goto~
**** Re-Using Implementations
+ The default implementation of ~ms-end~ is achieved by just walking forward from ~ms-init~, calling ~ms-step-forward~ until it returns =nil=.

+ Implementing ~ms-goto~ is optional as long as ~ms-init~ and ~ms-step-forward~ can implement ~ms-end~ and report their furthest extent of progress accurately.

+ Ideally ~ms-forward~ & ~ms-backward~ along with ~ms-init~ & ~ms-end~ form a closed system, but for the convenience of the implementer, it's fine to use an idempotent ~ms-init~ as the ~ms-backward~ step if granular backward is difficult or not valuable to implement.
** Sequence Composition
Navigating a tree involves depth.  Descendants may care about what happened in ancestors.  Ancestors may care about what descendants leave behind.  There may be conventions about what happens when descending into a child or returning from one.
*** Call Stack Execution
Like the command pattern is a helpful model for designing forward and backwards presentation navigation, the [[https://en.wikipedia.org/wiki/Call_stack][call stack]] is a helpful model for understanding composition of our stateful sequences.

In the model call stack, the caller & callee only cooperate at the call site or by side-effects, aka globals.  If callee is pure, the call site is the only way that they communicate.

Slides are mostly pretty pure.  The provided actions generally do not look outside of the contents of the heading they are attached to.  If they touch the child headings, it is generally to hydrate them into slides and then forward stateful sequence calls into them.
**** Actions are like Sub-Routines
A sub-routine is generally coupled to its containing routine.  It may do work in addition to other sub-routines or even cooperate with them via ad-hoc coupling.  While the function call stack is nice and clean, because actions run concurrently and might be working on the same parts of the buffer, they are the dirty guts within the near isolation of the slide.
*** Child, Section, and Slide
It is extremely natural that a slide action will fill one of three roles:
- Narrow to the contents its actions work on
- Perform some steps on the heading's section
- Perform steps on the heading's children, including instantiating slides and calling their methods, which may narrow to them
**** Multiple Slide Property Keys
The three natural roles for actions are why there are more than one heading property for configuring actions.  Each action is easier to implement if they only fill one role.  It is easier for the user to configure a slide if they only have to declare one action.  By breaking up the slide's typical actions, we can configure with enough granularity to usually only touch one heading property.  The only drawback is that hydration has to do a little bit of extra work.
*** Trees & Stacks
If something depends on something else existing or having been set up, its lifetime must be fully encompassed by that other thing.  Especially since we are going forward & backward, cleanups must happen on both ends of a sequence.

It is natural that a parent heading out-lives its child.  User can take advantage of this by using the document or higher level headings to store state that needs to be shared by children.  The ~final~ calls for those things can call cleanup.
*** Slides & Action Lifetime
Actions live, for the most part, as long as the slide.  Their ~ms-init~ method is called at the very beginning.  An action that reveals items must hide them before the user first sees them.

A consequence of this is that there are usually multiple actions alive at once.  Something has to hold onto them.  Right now, it's the slide.   There is only one slide usually in play, and it holds a reference to its parent so that it can "return".  üöß In the future, the actions may hold onto child actions and only one action might be alive at a time.  This would be desirable.  It just takes some mild rework of the implementation.
* Contributing
- Since you likely just need something to magically happen, the recommended option is to place a hamburger in the [[https://github.com/sponsors/positron-solutions][hamburger jar]] and file an issue.
- If you do have time, excellent.  Happy to support your PR's and provide context about the architecture and behavior.
** Work In Progress üöß
Open issues and give feedback on feature requests.  Contributions welcome.
*** Display Options
Some hooks or explicit display buffer calls may be beneficial.
*** Secondary Commands
See the section about bindings for context.  Video play or other situations where the presentation might branch should be supported by overloading the behavior of ~ms-start~
*** ~ms-goto~, starting from point
Since not many actions currently have implemented this very accurately, playing from point is likely not that accurate.  Progress updating in the base buffer is also currently only at the slide level of granularity.
*** Affiliated Buffers
There is no tracking whether a buffer is part of the presentation or not.  How would a buffer become one?  Should it be implicit?  Without any sort of tracking, the consequence is that having a presentation open leaves the minor mode bindings hot.  These commands do weird things when run from these situations, especially if running babel scripts, so some kind of first-class buffer affiliation seems necessary.
*** Mode Lifecycle
Starting and stopping the mode need some work.  The minor mode is global, so it's sensitive in every buffer, but it doesn't always call things in the right buffer.  I think double-start also still has a bug.  Easy to clean up.
*** Non-Graphic Display
For terminals, the line-height based slide-in effect is not supported.
*** Sub-Sequence Call & Restore
Sequences are often enclosed within other sequences, but there is currently no support for pushing or popping states when entering or exiting sequences.  It's just not clear yet what cooperation might be necessary at sub-sequence boundaries.
*** Non-Org Sequences
There's no concrete reason why presentations need to start with Org mode buffers.  The deck object could have its org-specific functionality pushed down to an org-mode class.  The only requirement is to be able to hydrate some stateful sequences, which may hydrate and call into sub-sequences, meaning anything is pretty trivially possible.
*** Heading Filtering
This was not implemented yet, but evidently some had been filtering their headlines to only show TODO's in ~org-tree-slide~.  Perhaps it is convenient to filter some tags and prevent them from being instantiated, especially if they will fail.
*** Counting Slides
Especially if slides launch sub-sequences, and they do it from Lisp, this is hard.  Buffer slides and also slide actions make it somewhat ambiguous.  Counting trees or tracking the point might be easier.  A ~children~ method for sequences works as long as sequences actually implement it.
*** Improper Levels
Children with no parents or missing a level are currently not supported and likely cause bad behavior.
* Thanks & Acknowledgments
This package is a direct descendant of Takaaki ISHIKAWA's [[https://github.com/takaxp/org-tree-slide][org-tree-slide]] package.  Many of the ideas and some of the implementations were either inherited or inspired by ideas from that package.  This package would not exist without the inspiration.  Thanks to everyone who contributed on org-tree-slide.
