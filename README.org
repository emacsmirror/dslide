#+title:	Macro Slides
#+author:	Positron
#+email:	contact@positron.solutions

* Installation
This isn't on a package archive yet.  Subscribe to Positron's [[https://www.youtube.com/@Positron-gv7do][YouTube]] for updates.
 #+begin_src elisp
   ;; package-vc
   (package-vc-install
    '(macro-slides
      :url "https://github.com/positron-solutions/macro-slides.git"))

   ;; using elpaca's with explicit recipe
   (use-package macro-slides
     :elpaca (macro-slides :host github
                           :repo "positron-solutions/macro-slides"))

   ;; straight with explicit recipe
   (use-package macro-slides
     :straight (macro-slides :type git :host github
                             :repo "positron-solutions/macro-slides"))

   ;; or use manual load-path & require, you brave yak shaver
 #+end_src
** Try It Out
With just defaults, run ~ms-start~ on your existing documents.  You can load the examples in the =/test= directory to see a showcase of configuration behavior.
* Overview
- A presentation framework that can incorporate *anything* Emacs does
- Any buffer can be part of a presentation sequence
- Present Org documents with babel integration
- Extensible presentation sequences and display options
** Simple User Interface
Fully programmable sequences behind a two-button interface:
- ~ms-forward~
- ~ms-backward~
** Present Org Documents
- Document header generated from keywords
- Breadcrumbs
- Every heading and child heading is a slide
** Fully Programmable
- Configurable slide behavior using pre-built actions
- Convenient API for quickly writing reliable custom actions
- Integration with Elisp programs, arbitrary Emacs buffers, and scripting with Org Babel
- Custom class support for extending the framework
** Status
üë∑üõ†Ô∏è Version 0.2.0 to begin receiving API feedback and feature requests etc.  Please check the issues and weigh in on other users proposals and PR's.

The internal API is beginning to stabilize.  I think the user API will look pretty similar to what is already there today, but if any keys change, I'll call ~warn~ on the old keys.
* Features
** Contents Navigation
Call ~ms-contents~ to show a contents overview.  Calling ~ms-forward~ and ~ms-backward~ in the contents can quickly move through headings.  Call ~ms-start~ again to resume the presentation from that point.
** Clean Buffer State
The actual display is done in an indirect buffer.  Your hooks and customizations for presentation will not pollute your editing buffer.  Dirty state will not pile up in your presentation buffer, greatly increasing reliability even if your custom Elisp scripting is sloppy.
** Follow Along
If you display the slideshow in one window or frame, you can configure the point to follow the slide in the base buffer, enabling you to see the full markup and even edit the presentation while developing your customizations.
* Glossary
- *Deck*: an object that is used to relate the display and base buffer and is the root of all sequences
- *Slide*: an object that interprets an org heading to hydrate its actions
- *Action*: an object that responds to ~ms-forward~ and ~ms-backward~ calls and implements lifecycle methods to initialize and clean up state
- *Step*: a single call to ~ms-foward~ or ~ms-backward~, usually delegated down to ~ms-step-forward~ and ~ms-step-backward~ methods

- *Contents*: use org folding to create a view of folded headings to quickly navigate slides
- *Display Buffer*: the slides are shown in an indirect buffer that is cloned from your org document buffer.  The source is called the *base buffer*.  Check for the =deck: my-presentation.org= buffer name
- *Buffer-Slide*: When integrating a buffer into the presentation, ~ms-buffer-slide-mode~ sets up the keybindings and links the buffers via the deck object, enabling the presentation to control the buffer.
* Configuring
Be sure to check =M-x= ~customize-group~ =macro-slides= to see all declared custom variables.

Many settings can be configured at the global level through customize variables, the document level through keywords, and the slide level through the property drawer.

There's a lot of hooks and variables.  All of the variables are configured to recommended defaults except hooks, which would depend on other packages usually.
** Recommended MC Settings
The out-of-the-box experience can be a bit messy due to property drawers, keywords, and babel blocks that you might include.  You probably want to hide these elements.  [[https://github.com/positron-solutions/master-of-ceremonies][Master of Ceremonies]] contains some flexible hiding that can be updated with each slide and turned on and off only when the slideshow is active.
#+begin_src elisp
  ;; Something like this should work
  (add-hook 'ms-mode-hook (lambda () (mc-hide-mode (if ms-mode 1 -1))))
  (add-hook 'ms-narrow-hook #'mc-hide-refresh)
#+end_src
** Heading Properties
Headings are treated as slides.  Slides have actions.  Actions are configured in the property drawer.

- =SLIDE_ACTION=: Usually narrows to the slide.  Lifecycle encloses the section.
- =SLIDE_SECTION_ACTIONS:= Most commonly customized.  You can list multiple actions.  Each one will step through its forward and backward steps.
- =SLIDE_CHILD_ACTION=: Used to customize if and how child headings become slides

Some actions must be fully enclosed by the lifecycle of a surrounding action, such as narrowing to the headline and section before displaying a contained list item-by-item.

üöß Likely in the future, actions will be composable and accept arguments, using Lisp s-expressions.  This API should be forward compatible.
*** Example
Regular Org Mode markup is used to add actions to headings.  See more examples in the [[../test]] directory.
#+begin_src org
  ,* Full Screen Images
  :PROPERTIES:
  :SLIDE_ACTIONS: ms-action-images
  :END:
  ,#+attr_html: :width 50%
  [[./images/emacsen4.jpeg]] [[./images/before-google3.jpeg]]
#+end_src

* Customizing
** Sub-classing
The deck and slide class as well as actions can all be sub-classed.  Use the existing sub-classes of actions as example code for writing other classes.
** Babel Scripting
You can write custom scripts into your presentation as Org Babel blocks.  These can be executed with the ~ms-action-babel~ action.  You just need to label your blocks with lifecycle methods if you want to be able to go forwards and backwards.  See the ~ms-action-babel~ class
** ~ms-start-function~
Typically the mode is entered via commands that are to be bound outside of the minor mode keymap.  If these commands want to start the mode a specific way, but they need to start the mode first, they just bind ~ms-start-function~ to override the last step of starting the mode.
* Package Pairings
This package is focused on creating a linear presentation sequence. For functionality not related to integrations into the ~ms-forward~ ~ms-backward~ interface, it is better to maintain separate packages and use hooks and babel scripting.
** Master of Ceremonies
The [[https://github.com/positron-solutions/master-of-ceremonies][master-of-ceremonies]] package contains utilities for display & presentation frame setup that are not specific to using Macro Slides.
- *hide markup*
- display a region full-screen
- silence messages during presentation
- hide the cursor or make it very subtle
- extract notes and display them in a separate frame
** Open Broadcaster Software
Sacha Chua has written an OBS plugin integration helpful for video integration [[https://github.com/sachac/obs-websocket-el][obs-websocket-el]].
** Orgit
~orgit~ can be used to show commits as links, which open with =ms-action-links=
** moom.el
The [[https://github.com/takaxp/moom#org-mode-org-tree-slide][moom]] package contains some commands for resizing text and repositioning frames.
* Domain Model
This is a description of how the pieces of the program *must* fit together.  For any deep customization or hacking, the section is essential reading.  At the least, it will *greatly improve your success*.

‚ö†Ô∏è Even if the current implementation differs, trust this domain model and expect the implementation to approach it.

- The user interface ~ms-forward~ and ~ms-backward~ is a concrete requirement that drives most of the rest of the implementation and feature design.
- There are several ways to linearize the tree structure of org headings and to compose their presentation.  Sequences of forward and backward actions must be nested to accomplish many desirable goals.
- Supporting nested sequences can be made to implement just about anything while still keeping the user interface simple.
** Stateful Sequence Class
This class is the heart of providing the common user interface and convenient implementation interface for extending the package.
*** Command Pattern
The basis of all undo systems is to implement reverse actions that decide their behavior from the updated state or to save mementos that allow undoing forward actions.  This is the [[https://en.wikipedia.org/wiki/Command_pattern][command pattern]].

Navigating the linear sequence of a presentation is very similar to an undo system.  Log-backed architectures such as git or event-sourcing can similarly be viewed as navigating to any point in a sequence by applying or rolling back a sequence of changes.
*** Setup & Teardown
At the boundaries of a sequence of forward and reverse actions, it may be necessary to build up or tear down some state.  The stateful sequence adds ~ms-init~, ~ms-final~, and a variation of ~ms-init~, ~ms-end~.

The role of ~ms-end~ is to perform initialization at the end.  It is optional as the default implementation is to call ~ms-int~ and then ~ms-step-forward~ until no more progress can be made.  However, this may be costly or undesirable due to side-effects.
*** Indexing Via Point
In order to support contents based navigation, we need to be able to play a slide forward up to the current point.  This may require instantiating some parent slides and playing them forward to a child.  To avoid the need for parents to know about children, the ~ms-goto~ method was introduced.
*** Stateful Sequence Interface
The conclusion of the command pattern, setup & teardown, and indexing via point is the ~ms-stateful-sequence~ class.  Anything that implements its interface can be controlled by ~ms-forward~ and ~ms-backward~.  The full interface:

- ~ms-init~ & ~ms-end~
- ~ms-final~
- ~ms-step-forward~ & ~ms-step-backward~
- ~ms-goto~
**** Re-Using Implementations
+ The default implementation of ~ms-end~ is achieved by just walking forward from ~ms-init~, calling ~ms-step-forward~ until it returns =nil=.

+ Implementing ~ms-goto~ is optional as long as ~ms-init~ and ~ms-step-forward~ can implement ~ms-end~ and report their furthest extent of progress accurately.

+ Ideally ~ms-forward~ & ~ms-backward~ along with ~ms-init~ & ~ms-end~ form a closed system, but for the convenience of the implementer, it's fine to use an idempotent ~ms-init~ as the ~ms-backward~ step if granular backward is difficult or not valuable to implement.
** Sequence Composition
Navigating a tree involves depth.  Descendants may care about what happened in ancestors.  Ancestors may care about what descendants leave behind.  There may be conventions about what happens when descending into a child or returning from one.
*** Call Stack Execution
Like the command pattern is a helpful model for designing forward and backwards presentation navigation, the [[https://en.wikipedia.org/wiki/Call_stack][call stack]] is a helpful model for understanding composition of our stateful sequences.

In the model call stack, the caller & callee only cooperate at the call site or by side-effects, aka globals.  If callee is pure, the call site is the only way that they communicate.

A slide action can be seen as an impure function.  Actions to display the section might look at the buffer restriction state to determine if they need to add themselves to the buffer restriction or completely take over display.
*** Child, Section, and Slide
It is extremely natural that a slide action will fill one of three roles:
- Narrow to the contents its actions work on
- Perform some steps on the heading's section
- Perform steps on the heading's children, including instantiating slides and calling their methods, which may narrow to them
**** Multiple Slide Property Keys
These natural roles are why there are more than one heading property for configuring actions.  Each action is easier to implement if they only fill one role.  It is easier for the user to configure a slide if they only have to declare one action.  By breaking up the slide's typical actions, we can configure with enough granularity to usually only touch one heading property.
*** Trees & Stacks
If something depends on something else existing or having been set up, its lifetime must be fully encompassed by that other thing.  Especially since we are going forward & backward, cleanups must happen on both ends of a sequence.

It is natural that a parent heading out-lives its child.  User can take advantage of this by using the document or higher level headings to store state that needs to be shared by children.  The ~final~ calls for those things can call cleanup.
*** Slides & Action Lifetime
Actions live, for the most part, as long as the slide.  Their ~ms-init~ method is called at the very beginning.  An action that reveals items must hide them before the user first sees them.

A consequence of this is that there are usually multiple actions alive at once.  Something has to hold onto them.  Right now, it's the slide.   There is only one slide usually in play, and it holds a reference to its parent so that it can "return".  üöß In the future, the actions may hold onto child actions and only one action might be alive at a time.  This would be desirable.  It just takes some mild rework of the implementation.
* Work In Progress üöß
Open issues and give feedback on feature requests.  Contributions welcome.
** TODO Contents
I seem to have forgotten again to implement starting at the point or navigating via contents.  Well, let's add it +tomorrow.+ Thursday?
** Mode Lifecycle
Starting and stopping the mode need some work.  The minor mode is global, so it's sensitive in every buffer, but it doesn't always call things in the right buffer.  I think double-start also still has a bug.  Easy to clean up.
** Non-Graphic Display
For terminals, the line-height based slide-in effect is not supported.
** Sub-Sequence Call & Restore
Sequences are often enclosed within other sequences, but there is currently no support for pushing or popping states when entering or exiting sequences.  It's just not clear yet what cooperation might be necessary at sub-sequence boundaries.  Slide display looking at the restriction state is one such boundary.
** Non-Org Sequences
There's no concrete reason why presentations need to start with Org mode buffers.  The deck object could have its org-specific functionality pushed down to an org-mode class.  The only requirement is to be able to hydrate some stateful sequences, which may hydrate and call into sub-sequences, meaning anything is pretty trivially possible.
** Heading Filtering
This was not implemented yet, but evidently some had been filtering their headlines to only show TODO's in ~org-tree-slide~.  Perhaps it is convenient to filter some tags and prevent them from being instantiated, especially if they will fail.
** Counting Slides
Especially if slides launch sub-sequences, and they do it from Lisp, this is hard.  Buffer slides and also slide actions make it somewhat ambiguous.  Counting trees or tracking the point might be easier.  A ~children~ method for sequeneces works as long as sequences actually implement it.
** Improper Levels
Children with no parents or missing a level are currently not supported and likely cause bad behavior.
* Thanks & Acknowledgments
This package is a direct descendant of Takaaki ISHIKAWA's [[https://github.com/takaxp/org-tree-slide][org-tree-slide]] package.  Many of the ideas and some of the implementations were either inherited or inspired by ideas from that package.  This package would not exist without the inspiration.  Thanks to everyone who contributed on org-tree-slide.
